#define _CRT_SECURE_NO_WARNINGS

#include <cassert>
#include <cstdio>
#include <cstdlib>
#include <ctime>

void sort(int arr[1000],int counter) {
	int* p;
	p = arr-1;

	//EAX	Аккумулятор
	//ECX	Счётчик
	//EDX	32	Регистр данных
	//MOV 	 Эта команда перемещает значение из источника в приемник.
	//ESI	32	Индекс источника -тут выполняет роль указателя на начало массива

	//Команда cmp расшифровывается, как compare, что переводится как "сравнить".
	//Команда je расшифровывается, как jump if equal, что переводится как "прыгнуть если равно".
	//Эта команда переходит к метке, если в результате последнего вызова команды cmp первый операнд был равен второму

	//Команда jge расшифровывается, как jump if greater or equal, что переводится как "прыгнуть если больше или равно".
	//Эта команда переходит к метке, если в результате последнего вызова команды cmp первый операнд был больше или равен второму.


	_asm {

		mov esi, p // Эта инструкция перемещает адрес массива arr(сохраненный в указателе p) в регистр esi.
		//esi будет использоваться в качестве указателя индекса для доступа к элементам массива.

		mov ecx, counter
		//Эта команда перемещает значение переменной counter(которая представляет количество элементов в массиве) в регистр ecx.
		//ecx будет использоваться в качестве счетчика циклов.


		outer:
		mov edx, ecx //mov edx, ecx: Эта инструкция инициализирует регистр edx значением ecx.
		//edx будет использоваться в качестве второго указателя индекса для вложенных циклов.


		inner:
		cmp edx, ecx
		//Эта инструкция сравнивает значения в регистрах edx и ecx. Он устанавливает флаги на основе результата сравнения, которые будут использоваться при последующих условных переходах.

		je exchangeNo
		//Эта инструкция переходит к метке exchange No, если предыдущее сравнение (cmp edx, ecx) привело к равенству (т.е. edx равно ecx).

		mov eax, [esi + ecx * 4]
		//Эта команда загружает значение из ячейки памяти, на которую указывает[esi + ecx * 4], в регистр eax.Он извлекает ecx - й элемент массива arr.//квадратные скобки-разыменовывание указателей

		mov ebx, [esi + edx * 4]

		cmp eax, ebx
		//Эта инструкция сравнивает значения в регистрах eax и ebx. Он устанавливает флаги на основе результата сравнения, которые будут использоваться при последующих условных переходах.

		jge exchangeNo
		//Эта инструкция переходит к метке exchange No, если предыдущее сравнение (cmp eax, ebx) привело к значению больше или равно (т.е. eax больше или равно ebx).


		mov[esi + ecx * 4], ebx
		//Эта инструкция сохраняет значение в регистре ebx в ячейке памяти, на которую указывает [esi + ecx * 4]. При необходимости он заменяет ecx-й элемент arr на edx-й элемент.

		mov[esi + edx * 4], eax
		//Эта инструкция сохраняет значение в регистре eax в ячейке памяти, на которую указывает[esi + edx * 4].Он завершает операцию подкачки, помещая исходное значение arr[ecx] в arr[edx].

		exchangeNo :
		//Это метка, которая отмечает местоположение для перехода, если сравнение в инструкциях je или jge имеет значение false.

		dec edx

		jge inner
		//Эта инструкция переходит к внутренней метке, если предыдущее сравнение (dec edx) привело к значению больше или равно (т.е. edx больше или равно 0). Он продолжает внутренний цикл до тех пор, пока все элементы не будут сравнены и при необходимости заменены местами.

		loop outer
		//Эта инструкция уменьшает значение ecx на 1 и переходит к внешней метке, если значение ecx больше 0. Он повторяет внешний цикл до тех пор, пока все элементы не будут отсортированы.
		}
}

int main() {


	int arr[1000];
	int counter = 0;

	FILE* input_ = fopen("input.txt", "w");

	assert(input_ != NULL);


	srand(time(nullptr));


	int amount = rand() % 1000 + 1;


	for (int i = 0; i < amount; i++) {
		int randomNumber = rand();
		fprintf(input_, "%d\n", randomNumber);
	}


	fclose(input_);


	FILE* input = fopen("input.txt", "r");

	assert(input != NULL);


	while (fscanf(input, "%d", &arr[counter]) != EOF and counter < 1000)
		++counter;
	fclose(input);


	sort(arr,counter);


	/*В сборке x86 доступ к элементам массива обычно осуществляется с использованием байтовых смещений.
	Поскольку каждый элемент в массиве имеет тип int(размер 4 байта), умножение индекса(ecx или edx) на 4 используется для вычисления смещения в байтах от базового адреса(esi).
	Например, если ecx содержит индекс 1, умножение его на 4 дает смещение в байтах, равное 4, что соответствует второму элементу массива(myarray[1]).
	Аналогично, умножение edx на 4 дает смещение в байтах для элемента с индексом edx.*/


	FILE* output = fopen("output.txt", "w");
	assert(output != NULL);


	for (int i = 0; i < counter; i++)
		fprintf(output, "%d\n", arr[i]);
	fclose(output);
}
