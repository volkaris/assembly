#define _CRT_SECURE_NO_WARNINGS
#include <cassert>

#include <cstdio>
#include <cstdlib>
#include <ctime>


int main() {


	FILE* input_ = fopen("input.txt", "w");

	assert(input_ != NULL);


	srand(time(NULL));

	
	int amount = rand() % 1000 + 1;

	
	for (int i = 0; i < amount; i++) {
		int randomNumber = rand();
		fprintf(input_, "%d\n", randomNumber);
	}

	
	fclose(input_);


	FILE* input = fopen("input.txt", "r");

	assert(input != NULL);


	int myarray[1000];
	int counter = 0;

	while (fscanf(input, "%d", &myarray[counter]) != EOF and counter < 1000)
		++counter;
	fclose(input);



	int* p;
	p = myarray - 1;

	//EAX	Аккумулятор
	//ECX	Счётчик
	 //EDX	32	Регистр данных
	 //MOV 	 Эта команда перемещает значение из источника в приемник.
	//ESI	32	Индекс источника -тут выполняет роль указателя на начало массива

	//Команда cmp расшифровывается, как compare, что переводится как "сравнить".
	//Команда je расшифровывается, как jump if equal, что переводится как "прыгнуть если равно".
	//Эта команда переходит к метке, если в результате последнего вызова команды cmp первый операнд был равен второму

	//Команда jge расшифровывается, как jump if greater or equal, что переводится как "прыгнуть если больше или равно".
	//Эта команда переходит к метке, если в результате последнего вызова команды cmp первый операнд был больше или равен второму.



	_asm {
		
		mov esi, p		  // Эта инструкция перемещает адрес массива myarray(сохраненный в указателе p) в регистр esi.
						 //esi будет использоваться в качестве указателя индекса для доступа к элементам массива.

		mov ecx, counter //Эта команда перемещает значение переменной counter(которая представляет количество элементов в массиве) в регистр ecx.
						//ecx будет использоваться в качестве счетчика циклов.
	

		outer :
		mov edx, ecx   //mov edx, ecx: Эта инструкция инициализирует регистр edx значением ecx.
						//edx будет использоваться в качестве второго указателя индекса для вложенных циклов.
		

		inner :
		cmp edx, ecx	//Эта инструкция сравнивает значения в регистрах edx и ecx. Он устанавливает флаги на основе результата сравнения, которые будут использоваться при последующих условных переходах.

		je exchangeNo  //Эта инструкция переходит к метке exchange No, если предыдущее сравнение (cmp edx, ecx) привело к равенству (т.е. edx равно ecx).

		mov eax, [esi + ecx * 4]	//Эта команда загружает значение из ячейки памяти, на которую указывает[esi + ecx * 4], в регистр eax.Он извлекает ecx - й элемент массива myarray.//квадратные скобки-разыменовывание указателей

		mov ebx, [esi + edx * 4]

		cmp eax, ebx   //Эта инструкция сравнивает значения в регистрах eax и ebx. Он устанавливает флаги на основе результата сравнения, которые будут использоваться при последующих условных переходах.

		jge exchangeNo	 //Эта инструкция переходит к метке exchange No, если предыдущее сравнение (cmp eax, ebx) привело к значению больше или равно (т.е. eax больше или равно ebx).


		mov[esi + ecx * 4], ebx	 //Эта инструкция сохраняет значение в регистре ebx в ячейке памяти, на которую указывает [esi + ecx * 4]. При необходимости он заменяет ecx-й элемент myarray на edx-й элемент.

		mov[esi + edx * 4], eax	 //Эта инструкция сохраняет значение в регистре eax в ячейке памяти, на которую указывает[esi + edx * 4].Он завершает операцию подкачки, помещая исходное значение myarray[ecx] в myarray[edx].

		exchangeNo :   //Это метка, которая отмечает местоположение для перехода, если сравнение в инструкциях je или jge имеет значение false.

		dec edx

		jge inner  //Эта инструкция переходит к внутренней метке, если предыдущее сравнение (dec edx) привело к значению больше или равно (т.е. edx больше или равно 0). Он продолжает внутренний цикл до тех пор, пока все элементы не будут сравнены и при необходимости заменены местами.

		loop outer	 //Эта инструкция уменьшает значение ecx на 1 и переходит к внешней метке, если значение ecx больше 0. Он повторяет внешний цикл до тех пор, пока все элементы не будут отсортированы.
		}


	/*В сборке x86 доступ к элементам массива обычно осуществляется с использованием байтовых смещений.
	Поскольку каждый элемент в массиве имеет тип int(размер 4 байта), умножение индекса(ecx или edx) на 4 используется для вычисления смещения в байтах от базового адреса(esi).
	Например, если ecx содержит индекс 1, умножение его на 4 дает смещение в байтах, равное 4, что соответствует второму элементу массива(myarray[1]).
	Аналогично, умножение edx на 4 дает смещение в байтах для элемента с индексом edx.*/



	FILE* output = fopen("output.txt", "w");
	assert(output != NULL);



	for (int i = 0; i < counter; i++)
		fprintf(output, "%d\n", myarray[i]);
	fclose(output);


}
